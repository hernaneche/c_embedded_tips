<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="utf-8"/><link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/black.css">
        <!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">			    
                <section><h3>A lesson learned in life <br> Known from the dawn of time</h3>
                </section>                    
                <section><h4>Premature optimization is the root of all evil</h4>
                </section> 
                <section>                                 
                <h4> Ariadne 5 </h4>
                Ariadne 5, un cohete de la European Space Agency, fue lanzado el 4 de Junio de 1996.<br>
                37 segundos después era una bola de fuego.<br>
                    
                El módulo Inertial Navigation System que hacía los cálculos para apuntar el propelente del cohete y mantenerlo dirección,
                convirtió un float grande de 64-bit a un 16-bit signed (un Integer de lenguaje Ada) causando overflow.<br>                     
                No se chequeó la conversión, ¿por optimizar?<br>
                 </section>
                <section>
                <h4> Ariadne 5 </h4>                
                El hardware se detuvo, tomó el control la unidad de respaldo, idéntica con el mismo error, falló también.<br>
                La computadora interpretó como válidos datos fuera de rango, desvió la boquilla, el cohete giró al extremo y quedó expuesto a fuerzas para las que no estaba diseñado.<br>                
                <img src="img/ariadne5.gif" title="http://www.yourdailytrends.com/images/uploads/b746828fe1b0571b645fcaf96e01c27c.gif">
                </section>                
                <section>                                                   
                 <h4>A la belleza incremental..just say NO</h4>                                        
                    <ul>
                    <li>Primero el latido, los detalles después<br></li>
                        (mejor aún, nunca)
                    <li>Causa y Efecto: cosas de historiadores, fábulas.</li>                    
                    <li>Conexión proceso-resultado suele ser incomprensible.</li>                                                            
                    </ul><br><br>
                    <i>La belleza de una obra no necesita estar en el proceso de construcción.</i>
                 </section>       
                 <section>
                    <h4>A la belleza incremental..just say NO</h4>
                     <i>"Así como &pi; no puede sospecharse entre los infinitos términos de una serie que la calcule, menos aún aparecer literalmente entre ellos. Una gran obra nunca figura ni se deduce de los términos de su secuencia de construcción"<br><br>

                        "La belleza de una persona no se encuentra entre los pliegues de los genitales peludos de sus progenitores, aunque hubieran sido necesarios durante el proceso de reproducción."</i>
                 </section>
                 
                <section><h4>La pureza, independencia, desacople</h4><br>
                    Son fantasías
                </section>								
                <section><h4>La Inter-dependencia en Teoría</h4> 
                    <img style="width:40%" src="img/mc_escher_bird_design_fragment0001.jpg" title="http://rstessellation.wikispaces.com/file/view/mc_escher_bird_design_fragment0001.jpg"><br>
                    <img src="img/Pentagonal_tiling_type_9_animation.gif" title="https://en.wikipedia.org/wiki/Pentagonal_tiling#/media/File:Pentagonal_tiling_type_9_animation.gif">			  	
                </section>					

                <section><h4>La Inter-dependencia en la Práctica</h4> 
                <div>
                <img src="img/PanteraProjectsInTheJungle.jpg" title="https://upload.wikimedia.org/wikipedia/en/thumb/7/73/PanteraProjectsInTheJungle.jpg/220px-PanteraProjectsInTheJungle.jpg">			  	
                </div>
                    <i>Projects in the Jungle</i><br>
                </section>					
                <section><h4>Tipos de Datos</h4>
                    <ul>
                    <li>Le dan sentido al compilador (sino usar javascript o hacer diseño gráfico)</li>                
                    <li>En C facilitan más al compilador, para encajar con el micro, que al programador</li>
                    <li>Tipos primitivos: evitar</li>
                    </ul>
                </section>
                <section><h4>Tipos primitivos, casos necesarios</h4>                                        
                    <ul>
                    <li>Datos cercanos a hard: bytes, words. Usar &lt;stdint.h&gt;</li>                    
                    <li>Para declarar tipos compuestos (typedef struct) disfraza a C de "fuertemente" tipado</li>                    
                    </ul>
                    <pre><code data-trim data-noescape>
                    typedef struct {
                        uint32_t contador;
                        uint8_t flags;
                    }DatoCompuesto_t;
                    </code></pre>                    
                    No está de más repetir, <i>siempre</i> usar <b>&lt;stdint.h&gt;</b>
                </section>                
                <section>				
                    <h4>const</h4>
                    <i>const</i> siempre y en todos los argumentos, hasta que No compile nada. Partir de ahí.
                </section>				  
                <section><h4>Float, Double</h4>
                    No usar.
                </section>              
                <section>
                    <h4>Sleeps, retardos</h4>
                    No usar.
                </section>                              
                <section>
                    <h4>Threads</h4>
                    No usar.
                </section>
                <section>
                    <h4>for, loops</h4>
                    1 solo.
                </section>                
                <section>
                    <h4>if</h4>
                    No usar, salvo necesidad extrema.<br>
                    Cuestionar los ifs ¿qué hace ahí?¿Por qué necesita el programa preguntar eso?<br>
                    Menos ifs, menos combinaciones, menos sorpresas y errores.<br>                    
                </section>
                <section>
                    <h4>if</h4>                    
                    La función del código debe estar embebida en su naturaleza, si no sabe lo que hace, no lo compensará preguntando con ifs y variables<br>                    
                    El contexto de la función, el tipo de dato de los argumentos, la posición de ejecución, etc, deben diseñarse, son información útil.<br>
                    Chequear todas las combinaciones posibles no es hacer un programa.<br>
                    «Quod natura non dat, Salmantica non præstat»                          
                    Evitar chequear una y otra vez en variables lo que el código ya sabe, tanto el encapsulamiento, la posición de ejecución, el tipo de datos, deben representar información que ahorra preguntas.<br>
                </section>
                <section><h3>Tipos Bit/Boolean</h3>
                    False. No usar.<br>
                    Una macros útiles para bits:
                    <pre><code data-trim data-noescape>
#define SETBIT(var, nbit) ((var)|=(1UL<<(nbit)))
#define CLRBIT(var, nbit) ((var)&=(~(1UL<<(nbit))))
#define BITAT(var, nbit) ((var)&(1<< (nbit)))
                    </code></pre>
                </section>
                <section><h3>Para chequear "booleans"</h3>
                    <pre><code data-trim data-noescape>
                    if ( x!=0 ), mejor que if ( x==1 )
                    </code></pre>
                     Pero mejor aún constantes con nombres, enums, etc..
                     Obviamente NO a los magic numbers.
                    <pre><code data-trim data-noescape>
                    if ( musica != PANTERA  ) { 
                       break;
                    }
                    </code></pre>
                    código claro                    
                </section>                       
                <section>                                                               
                    <h3><i>int</i> es enemigo, un mal innecesario</h3>
                    aceptarlo, conocerlo, es tipo default en constantes, esa basura convivirá con C hasta que se extinga en el infierno.  
                </section>                                                                                                       
                <section>
                    <h3>Periféricos, y DMA are friends</h3>
                    Todo lo que se pueda hacer por Hardware mejor (hard EXTERNO, aún mejor) 
                </section>				 
                <section>
                    <h3>RTOS vs not RTOS</h3>    
                    La elección de la pastilla de matrix.
                </section>
                <section>
                    <h3>Linux</h3>  
                    Pastilla azul de matrix.
                </section>
                <section>
                    <h3>IRQ's are friends</h3>
                    Darle a la ISR tareas livianas, buffers, banderitas, pero nunca hard, ni write IO.
                </section>				
                <section>
                    <h3>Hard IO</h3>
                    Máquinas de estados. No excuses.
                </section>
                <section>	                                 
                    <h3><i>functions</i> are best friends</h3>
                    <ul>
                    <li>Las funciones son para separar y componer, no para ocultar.</li>
                    <li>Los nombres de las funciones son pistas de su función o inutilidad.</li>
                    <li>Aprender a programar es sobretodo crear, nombrar y renombrar funciones.</li>
                    </ul>
                </section>
                <section>	             
                    <h3><i>Callbacks</i> are risky friends</h3>
                    No usar, excepto en caso necesario.
                </section>
                <section>
                    <h3>Recursividad</h3>
                    No<br>                    
                </section>
                <section>
                    <h3>Reserva dinámica de memoria</h3>
                    No.
                </section>
                <section>
                    <h3>Arrays, peligrosos</h3>
                    Evitar, y si acaso, encapsular acceso donde sea posible.                    
                </section>                
                <section>
                    <h3>Strings en C: peligrosos (son arrays)</h3>
                    Mínimo: reemplazar todo uso de <b>strlen</b> por <b>strnlen</b><br>
                </section>
                <section>
                    <h3>Estados</h3>
                    NO. Ni globales, ni "static".<br>
                    <br>
                    Ok, se admiten algunos buffers y banderitas para que la amiga ISR nos informe.<br>                                        
                </section>                
                <section>
                    <h3><i>inline</i> functions</h3>
                    no confiar en el compilador.
                </section>
                <section>
                    <h3><i>volatile</i></h3>                    
                    no confiar en el compilador.<br> 
                    volatile, ok, pero no evita accesos no-atómicos,<br> 
                    no es para eso. <br>
                    Solución : ninguna, salvo horrible disable IRQ, CRITICAL_SECTION's<br>
                    minimizar lo compartido con ISR
               </section>                
            <section><h3>Varios</h3>
                    <ul>                    
                    <li> Usar git</li>
                    <li> Manejo dependencias: elegir uno fácil de migrar.</li> 
                    <li> Manejo compilación: elegir uno fácil de migrar.</li> 
                    <li> Frameworks, no usar: ninguno es fácil de migrar.</li>                 
                    <li> Datos: JSON (world peace of data format), si se necesita DB, usar clásicas, viejas. Contratar a alguien.</li>
                    </ul>
            </section>    
              <section>
                    <h3>Si no se entiende, REFACTOR</h3>    
                    A toda escala, excepto si es algo nuevo o en urgencias.
                </section>
                <section>                
                    <h4>NINGUNO es mejor que cualquier código<br>(casi siempre)</h4>
                    Las consecuencias de los cambios no son fácilmente previsibles.<br>
                    <img src="img/1FcKXFz.gif" title="http://i.imgur.com/1FcKXFz.gif">
                </section>
                <section>
                <h3>Futuro</h3>                
                    <ul>
                    <li> No. No diseñar estructuras "para futuro"</li>
                    <li> Ni una sola línea ¿adivina el futuro? vaya al casino.</li>
                    </ul>
                    <br>
                    Hello? Anybody home? ? Think, McFly! Think!<br><br>
                    <i>Es más probable reutilizar la cabeza que el código.</i>
                </section>
                <section>
                    "Por las dudas?"&lt;-- NADA<br><br>
                    ¿Qué dudas? <br><br>
                    Are you talking to me?<br>
                    ...walk on home boy<br>
                </section>
                <section>Respect, walk
                <!--audio autoplay>
                      <source src="mp3/respect1.mp3">
                </audio-->
            </section>
            </div>
        </div>
        <script src="js/reveal.js"></script>
        <script src="js/highlight.js"></script>
        <script>
            Reveal.initialize({
            dependencies:[{ src: 'plugin/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }]
            });
        </script>
    </body>
</html>
